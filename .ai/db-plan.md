# 10xCards Database Schema

## 1. Tables

### auth.users
This table is managed by Supabase Auth and provides user management functionality.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique identifier for the user |
| email | TEXT | UNIQUE, NOT NULL | User's email address |
| password | TEXT | NOT NULL | Hashed password (managed by Supabase) |
| created_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | When the user was created |
| updated_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | When the user was last updated |

### flashcards
Stores the flashcards created by users, including those generated by AI and accepted by the user.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique identifier for the flashcard |
| user_id | UUID | NOT NULL, REFERENCES auth.users(id) ON DELETE CASCADE | User who owns the flashcard |
| front_content | VARCHAR(500) | NOT NULL, CHECK (length(front_content) <= 500) | Front side content of the flashcard |
| back_content | VARCHAR(200) | NOT NULL, CHECK (length(back_content) <= 200) | Back side content of the flashcard |
| created_at | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | When the flashcard was created |
| is_ai_generated | BOOLEAN | NOT NULL, DEFAULT FALSE | Whether the flashcard was generated by AI |
| correct_answers_count | INTEGER | NOT NULL, DEFAULT 0 | Count of correct answers provided for this flashcard |

### flashcard_reviews
Records the history of user interactions with flashcards for the spaced repetition algorithm.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique identifier for the review |
| flashcard_id | UUID | NOT NULL, REFERENCES flashcards(id) ON DELETE CASCADE | The flashcard being reviewed |
| review_date | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT NOW() | When the review occurred |
| is_correct | BOOLEAN | NOT NULL | Whether the user answered correctly |
| difficulty_rating | ENUM | NOT NULL | User's rating of difficulty ('nie_pamietam', 'trudne', 'srednie', 'latwe') |
| next_review_date | TIMESTAMP WITH TIME ZONE | NOT NULL | When the flashcard should be reviewed next |
| session_id | UUID | NULL, REFERENCES learning_sessions(id) ON DELETE SET NULL | Session during which the review was performed |

### learning_sessions
Tracks learning sessions for users, including statistics about the session.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | UUID | PRIMARY KEY | Unique identifier for the session |
| user_id | UUID | NOT NULL, REFERENCES auth.users(id) ON DELETE CASCADE | User who owns the session |
| started_at | TIMESTAMP WITH TIME ZONE | NOT NULL, DEFAULT NOW() | When the session was started |
| ended_at | TIMESTAMP WITH TIME ZONE | NULL | When the session was completed |
| flashcards_count | INTEGER | NOT NULL | Total number of flashcards in the session |
| flashcards_reviewed | INTEGER | DEFAULT 0 | Number of flashcards reviewed in the session |
| correct_answers | INTEGER | DEFAULT 0 | Number of correct answers given |
| incorrect_answers | INTEGER | DEFAULT 0 | Number of incorrect answers given |
| is_due_only | BOOLEAN | DEFAULT FALSE | Whether the session includes only flashcards due for review |

## 2. Relationships

1. **auth.users (1) → flashcards (many)**
   - One user can have many flashcards
   - Each flashcard belongs to exactly one user

2. **flashcards (1) → flashcard_reviews (many)**
   - One flashcard can have many reviews
   - Each review is for exactly one flashcard

3. **auth.users (1) → learning_sessions (many)**
   - One user can have many learning sessions
   - Each learning session belongs to exactly one user

4. **learning_sessions (1) → flashcard_reviews (many)**
   - One learning session can have many flashcard reviews
   - Each flashcard review can optionally belong to one learning session

## 3. Indexes

### flashcards table
- `idx_flashcards_user_id` on `user_id` - Optimizes queries that filter flashcards by user
- `idx_flashcards_created_at` on `created_at` - Optimizes sorting by creation date

### flashcard_reviews table
- `idx_flashcard_reviews_flashcard_id` on `flashcard_id` - Optimizes joining with flashcards table
- `idx_flashcard_reviews_next_review_date` on `next_review_date` - Optimizes retrieval of flashcards due for review
- `idx_flashcard_reviews_review_date` on `review_date` - Optimizes sorting by review date
- `idx_flashcard_reviews_session_id` on `session_id` - Optimizes joining with learning_sessions table

### learning_sessions table
- `idx_learning_sessions_user_id` on `user_id` - Optimizes queries that filter sessions by user
- `idx_learning_sessions_started_at` on `started_at` - Optimizes sorting by start date

## 4. PostgreSQL Row Level Security (RLS) Policies

### flashcards table
```sql
ALTER TABLE flashcards ENABLE ROW LEVEL SECURITY;

-- Users can only view their own flashcards
CREATE POLICY flashcards_select_policy ON flashcards
  FOR SELECT USING (user_id = auth.uid());

-- Users can only insert flashcards for themselves
CREATE POLICY flashcards_insert_policy ON flashcards
  FOR INSERT WITH CHECK (user_id = auth.uid());

-- Users can only update their own flashcards
CREATE POLICY flashcards_update_policy ON flashcards
  FOR UPDATE USING (user_id = auth.uid());

-- Users can only delete their own flashcards
CREATE POLICY flashcards_delete_policy ON flashcards
  FOR DELETE USING (user_id = auth.uid());
```

### flashcard_reviews table
```sql
ALTER TABLE flashcard_reviews ENABLE ROW LEVEL SECURITY;

-- Users can only access reviews for flashcards they own
CREATE POLICY flashcard_reviews_select_policy ON flashcard_reviews
  FOR SELECT USING (
    flashcard_id IN (
      SELECT id FROM flashcards WHERE user_id = auth.uid()
    )
  );

-- Users can only insert reviews for flashcards they own
CREATE POLICY flashcard_reviews_insert_policy ON flashcard_reviews
  FOR INSERT WITH CHECK (
    flashcard_id IN (
      SELECT id FROM flashcards WHERE user_id = auth.uid()
    )
  );

-- Users can only update reviews for flashcards they own
CREATE POLICY flashcard_reviews_update_policy ON flashcard_reviews
  FOR UPDATE USING (
    flashcard_id IN (
      SELECT id FROM flashcards WHERE user_id = auth.uid()
    )
  );

-- Users can only delete reviews for flashcards they own
CREATE POLICY flashcard_reviews_delete_policy ON flashcard_reviews
  FOR DELETE USING (
    flashcard_id IN (
      SELECT id FROM flashcards WHERE user_id = auth.uid()
    )
  );
```

### learning_sessions table
```sql
ALTER TABLE learning_sessions ENABLE ROW LEVEL SECURITY;

-- Users can only view their own learning sessions
CREATE POLICY learning_sessions_select_policy ON learning_sessions
  FOR SELECT USING (user_id = auth.uid());

-- Users can only insert learning sessions for themselves
CREATE POLICY learning_sessions_insert_policy ON learning_sessions
  FOR INSERT WITH CHECK (user_id = auth.uid());

-- Users can only update their own learning sessions
CREATE POLICY learning_sessions_update_policy ON learning_sessions
  FOR UPDATE USING (user_id = auth.uid());

-- Users can only delete their own learning sessions
CREATE POLICY learning_sessions_delete_policy ON learning_sessions
  FOR DELETE USING (user_id = auth.uid());
```

## 5. Custom Types and Functions

### Difficulty Rating Enum
```sql
CREATE TYPE difficulty_rating AS ENUM ('nie_pamietam', 'trudne', 'srednie', 'latwe');
```

### Calculate Next Review Date Function
```sql
CREATE OR REPLACE FUNCTION calculate_next_review_date(
  p_current_date TIMESTAMP WITH TIME ZONE,
  p_difficulty_rating difficulty_rating,
  p_previous_interval INTEGER DEFAULT 0
) RETURNS TIMESTAMP WITH TIME ZONE AS $$
DECLARE
  v_next_interval INTEGER;
BEGIN
  -- Simple spaced repetition algorithm implementation
  -- Actual implementation will depend on the selected open source algorithm
  CASE p_difficulty_rating
    WHEN 'nie_pamietam' THEN
      v_next_interval := 1; -- 1 day
    WHEN 'trudne' THEN
      v_next_interval := GREATEST(2, p_previous_interval); -- At least 2 days
    WHEN 'srednie' THEN
      v_next_interval := GREATEST(4, p_previous_interval * 1.5::INTEGER); -- At least 4 days
    WHEN 'latwe' THEN
      v_next_interval := GREATEST(7, p_previous_interval * 2::INTEGER); -- At least 7 days
    ELSE
      v_next_interval := 1; -- Default fallback
  END CASE;
  
  RETURN p_current_date + (v_next_interval || ' days')::INTERVAL;
END;
$$ LANGUAGE plpgsql;
```

## 6. Design Notes

1. **Simplicity**: The schema is deliberately simple for the MVP, focusing on core functionality without additional complexity.

2. **Hard Delete Strategy**: As specified in the requirements, we use CASCADE deletion for user data when a user is deleted.
   Additionally, we use CASCADE deletion for flashcard_reviews when a flashcard is deleted, ensuring that all reviews
   associated with a deleted flashcard are also automatically removed from the database.

3. **Spaced Repetition Algorithm**: The next_review_date calculation is implemented as a database function, enabling consistent application of the algorithm across different parts of the application.

4. **Performance Considerations**:
   - Indexes have been added for columns that will be frequently used in WHERE clauses and JOIN conditions
   - Text columns have length limits to optimize storage and performance

5. **Data Integrity**:
   - Foreign key constraints ensure referential integrity
   - CHECK constraints enforce content length limits
   - RLS policies ensure users can only access their own data

6. **Supabase Integration**:
   - The schema leverages Supabase's built-in authentication system
   - RLS policies are designed to work with Supabase's auth.uid() function

7. **Learning Sessions**:
   - Sessions track a user's learning activity and progress
   - The `is_due_only` flag allows filtering for sessions that contain only flashcards due for review
   - Flashcard reviews can be associated with specific sessions via the `session_id` foreign key

8. **Future Expansion**:
   - While the current schema is simple, it provides a solid foundation for future features
   - Additional metadata could be added to the tables as requirements evolve

9. **AI-Generated Flashcards**:
   - AI-generated flashcards are initially returned to the client for user review
   - Only flashcards explicitly accepted by the user are saved to the flashcards table
   - The is_ai_generated flag distinguishes between manually created and AI-generated flashcards
   - This approach gives users full control over which generated flashcards to keep 